/*
Copyright (C) 2015 Apple Inc. All Rights Reserved.
See LICENSE.txt for this sampleâ€™s licensing information

Abstract:
This file contains an NSOperationQueue subclass.
*/

import Foundation

/**
    The delegate of an `DriftOperationQueue` can respond to `DriftOperation` lifecycle
    events by implementing these methods.

    In general, implementing `DriftOperationQueueDelegate` is not necessary; you would
    want to use an `DriftOperationObserver` instead. However, there are a couple of
    situations where using `DriftOperationQueueDelegate` can lead to simpler code.
    For example, `GroupOperation` is the delegate of its own internal
    `DriftOperationQueue` and uses it to manage dependencies.
*/
public protocol DriftOperationQueueDelegate: class {
    func operationQueue(_ operationQueue: DriftOperationQueue, willAddOperation operation: Foundation.Operation)
    func operationQueue(_ operationQueue: DriftOperationQueue, operationDidFinish operation: Foundation.Operation, withErrors errors: [Error])
}

extension DriftOperationQueueDelegate {
    public func operationQueue(_ operationQueue: DriftOperationQueue, operationDidFinish operation: Foundation.Operation, withErrors errors: [Error]) { }
}

/// The block that is called when operation is enqueued.
public typealias DriftOperationQueueEnqueuingModule = (operation: DriftOperation, queue: DriftOperationQueue) -> Void

/**
    `DriftOperationQueue` is an `NSOperationQueue` subclass that implements a large
    number of "extra features" related to the `DriftOperation` class:
    
    - Notifying a delegate of all operation completion
    - Extracting generated dependencies from operation conditions
    - Setting up dependencies to enforce mutual exclusivity
*/
public class DriftOperationQueue: Foundation.OperationQueue {
    
    /// - Note: Consider not to use `delegate` with your queues.
    /// There are better approaches, for example, enqueueing modules and operation observers.
    public weak var delegate: DriftOperationQueueDelegate?
    
    public override func addOperation(_ operation: Operation) {
        dependOnVitals(operation)
        if let operation = operation as? DriftOperation {
            
            // Set up an observer to invoke the `DriftOperationQueueDelegate` method.
            operation.observe {
                $0.didProduceAnotherOperation { [weak self] operation in
                    self?.addOperation(operation)
                }
                $0.didFinishWithErrors { [weak self] errors in
                    if let queue = self {
                        queue.delegate?.operationQueue(queue, operationDidFinish: operation, withErrors: errors)
                    }
                }
            }
            
            // Extract any dependencies generated by this operation conditions.
            let dependencies = operation.conditions.flatMap({ $0.dependencyForOperation(operation) })
                
            for dependency in dependencies {
                operation.addDependency(dependency)
                self.addOperation(dependency)
            }
            
            /*
                With condition dependencies added, we can now see if this needs
                dependencies to enforce mutual exclusivity.
            */
            let concurrencyCategories: [String] = operation.exclusivityCategories.map({ $0.categoryIdentifier })

            if !concurrencyCategories.isEmpty {
                // Set up the mutual exclusivity dependencies.
                let exclusivityController = ExclusivityController.sharedExclusivityController

                exclusivityController.addOperation(operation, categories: concurrencyCategories)
                
                operation.observe {
                    $0.didFinishWithErrors { _ in
                        exclusivityController.removeOperation(operation, categories: concurrencyCategories)
                    }
                }
            }
            
            // Connecting all user-defined modules. That's a fine alternative to delegates.
            for module in modules {
                module(operation: operation, queue: self)
            }
            
            /*
                Indicate to the operation that we've finished our extra work on it
                and it's now it a state where it can proceed with evaluating conditions,
                if appropriate.
            */
            operation._willEnqueue()
        }
        else {
            /*
                For regular `NSOperation`s, we'll manually call out to the queue's
                delegate we don't want to just capture "operation" because that
                would lead to the operation strongly referencing itself and that's
                the pure definition of a memory leak.
            */
            operation.addCompletionBlock { [weak self, weak operation] in
                guard let queue = self, let operation = operation else { return }
                queue.delegate?.operationQueue(queue, operationDidFinish: operation, withErrors: [])
            }
        }
        
        delegate?.operationQueue(self, willAddOperation: operation)
        super.addOperation(operation)
    }
    
    public override func addOperations(_ operations: [Operation], waitUntilFinished wait: Bool) {
        /*
            The base implementation of this method does not call `addOperation()`,
            so we'll call it ourselves.
        */
        for operation in operations {
            addOperation(operation)
        }
        
        if wait {
            for operation in operations {
              operation.waitUntilFinished()
            }
        }
    }
    
    private var modules: [DriftOperationQueueEnqueuingModule] = []
    
    /// Assigns a `module` which will be called when new `DriftOperation`s are added to the queue.
    public func addEnqueuingModule(_ module: DriftOperationQueueEnqueuingModule) {
        modules.append(module)
    }
    
    public struct EnqueuingOptions: OptionSet {
        public var rawValue: Int
        public init(rawValue: Int) {
            self.rawValue = rawValue
        }
        
        public static let Vital = EnqueuingOptions(rawValue: 1 << 0)
    }
    
    /// Adds an operation to the queue. The operation will "block" the queue if `vital` is true.
    ///
    /// - Parameter vital: If `true`, `operation` will be marked as vital (no other operation on the queue can start until this one is finished).
    public func addOperation(_ operation: Foundation.Operation, options: [EnqueuingOptions]) {
        if options.contains(.Vital) {
            addDependency(operation)
        }
        addOperation(operation)
    }
    
    public func addOperations(_ operations: Foundation.Operation...) {
        addOperations(operations, waitUntilFinished: false)
    }
    
    private let vitalAccessQueue = DispatchQueue(label: "com.AdvancedOperations.VitalOperationsAccessQueue")
    private var vitalOperations: [Foundation.Operation] = []
    
    private func dependOnVitals(_ operation: Foundation.Operation) {
        vitalAccessQueue.sync {
            for vital in self.vitalOperations where vital !== operation {
                operation.addDependency(vital)
            }
        }
    }
    
    /// Makes any newly added operation to the queue dependent on `operation`
    public func addDependency(_ operation: Foundation.Operation) {
        vitalAccessQueue.sync {
            self.vitalOperations.append(operation)
        }
        operation.addCompletionBlock { [weak self] in
            if let this = self {
                this.vitalAccessQueue.sync {
                    if let index = this.vitalOperations.index(of: operation) {
                        this.vitalOperations.remove(at: index)
                    }
                }
            }
        }
    }
    
}
